## операции инкремента и декремента 
инкремент - ++ - приоритет - высокий - арность - унарная - ассоциативность - правая
декремент - -- - приоритет - высокий - арность - унарная - ассоциативность - правая


## ФОРМЫ: префиксаня и постфиксная:
++i - перФиксная
--i

i++ - постфиксная
i--



a++ создаёт временную копию нашей переменной а, туда помещается копия --> далее мы увеличиваем а, после этого мы возвращаем копию, которую сделали туда, где работает наша операция. (13 строка)
при этом в а лежит новое значение.

```
#define _CRT_SECURE_NO_WARNINGS
#include <stdlib.h>
# include <stdio.h>
#include <time.h>

#define TASK_12

#ifdef TASK_1
int main() {
	int a = 5;
	printf("%d", a);
	a++;
	printf("%d", a);
	a++;
	printf("%d", a);
	printf("%d", a++);
	printf("%d", ++a);
	printf("%d\n", a);
	printf("%d", ++a + a++);

	return 0;

}
#endif TASK_1

```

# ЦИКЛ ФОР

алгоритм цикла for
1. инициализация переменной цикла (переменная от значения которой зависит истинность условия цикла for)
2. затем проверяется условие цикла for --> изменение переменной цикла
3. если условие истинное, выполнится тело цикла for
4. если условие истинно --> изменение перенной цикла
5. 
```
#ifdef TASK_2
int main() {
	for (int i = 0; i < 10; i++)
	{
		if (i == 5) {
			continue;
		}
		printf("%5d", i);
		printf("\n");
	}

	int i = 0;
	while (i < 10) {
	
		if (i == 5) {
			++i;
			continue;
		}
		printf("%5d", i);
		i++;
	}
	return 0;
}
#endif TASK_2
```

# ОПЕРАЦИЯ ПРИСВАИВАНИЯ

- имеет самый низки приоритет ниже только у запятой

присваивание "=" приоритет - самый низкий арность - бинаркая ассоциативность - гарантируется выполнение справа на лево

меняет только левый операнд
__________________
|L-value	|		R-value|
____________________
|может стоять слева от присваивания		|может стоять справа от присваивания|
___________________________________________________________________
|**требования:**|
______________
|не может быть константной		|	должно иметь значение|
_____________________________________________________
|должно иметь адрес|
_______________________
|**чем может быть:**|
______________________
|переменная|				переменная|
______________________
|функция		|		функция|
______________________
|указатель	|	указатель|
______________________
|объект	|		указатель на функцию |
______________________
|указатель на функцию	| указатель на массив|
______________________
|указатель на массив|		константа|
						имя массива
						выражение



```
#ifdef TASK_3
int main() {
	
	int myFavouriteVeryVeryVeryveryLonNameVariable = 15;
	myFavouriteVeryVeryVeryveryLonNameVariable *= 5 + 6;

	printf("%d\n", sizeof(5));

	int n = 0;

	scanf("%d", &n);
	switch (n) { //всегда фигурные скобки!!!
	case(1): printf("январь"); break;
	case(2): printf("февраль"); break;
	case(3): printf("март"); break;
	case(4): printf("апрель"); break;
	case(5): printf("май"); break;
	case(6): printf("июнь"); break;
	case(7): printf("июль"); break;
	case(8): printf("август"); break;
	case(9): printf("сентябрь"); break;
	case(10): printf("октябрь"); break;
	case(11): printf("ноябрь"); break;
	case(12): printf("декабрь"); break;
	default:
		printf("неправильный номер месяца");
	}

	return 0;
}
#endif TASK_3
```


## ОПЕРАЦИЯ SIZE_OFF
возвращает размер типа и размер переменной

```
#ifdef TASK_4
int main() {

	int n = 0;

	scanf("%d", &n);
	switch (n) { //всегда фигурные скобки!!!
	case(1): case(2): case(12): printf("winter"); break;
	case(3): case(4): case(5): printf("spring"); break;
	case(6): case(7): case(8): printf("Holidays"); break;
	case(9): case(10):case(11): printf("autumn"); break;
	default:
		printf("неправильный номер месяца");
	}

	return 0;
}
#endif TASK_4
```

## Бесконечные циклы
```
#ifdef TASK_5
int main() {
	/*бесконечные циклы*/
	//while (5) {
	//
	//}

	//do
	//	;
	//while (5);

	//for (;;);

	/*вложенный цикл*/
	for (int i = 0; i < 10; ++i) {
		for (int j = 0; j < 10; j++) {
			printf("%d x %d = %2d\t",i,j, i * j);
		}
		printf("\n");
	}

	return 0;
}
#endif TASK_5
```


## ОПЕРАТОРЫ УПРАВЛЕНИЯ

***return*** - возврат управления
***break ***- немедленный выход из цикла или switch

***continue*** - переход на следующую итерацию цикла

**goto** - безусловный переход на метку (использовать нельзя)

## МАССИВЫ

- последовательная группа ячеек памяти имеющих 1 тип и 1 имя

- массивы бывают динамические и статические

- размеры статического массива известен в момент компиляции программы (build-time) и не может меняться

- размер динамического массива может меняться во время работы программы (run-time)

- работа со статическим массивами проще, обращение к элементам происходит быстрее

- невнимательность в работе с динамическими массивами может приводить к ошибками времени выполнения

### ОБЪЯВЛЕНИЕ И ИНИЦИАЛИЗАЦИЯ
1. указываем тип элементов
2. имя массива
3. кол-во элементов массива в квадратных скобках
4. объявление с инициализацией - сразу написать все эл-ы

# index - это расстояние

```
#define SIZE 10

#ifdef TASK_6
int main() {
	/*
	int arr[10]; // тип имя[кол-во эл-в]

	int arr_1[10] = { 1,2,3,4,5,6,7,8,9,10 };

	for (int i = 0; i < 10; ++i) {
		printf("%d\n", arr_1[i]);
	}
	return 0;
	*/

	int arr[SIZE];
	const int koef = 10;

	for (int i = 0; i < SIZE; ++i) {
		arr[i] = i * koef;
		printf("%d\n", arr[i]);
	}

	return 0;

}
#endif TASK_6
```

## ЗАДАЧИ (примеры работы)


```
#ifdef TASK_7
int main() {
	
#define SIZE_COUNT 36000
#define STAT_SIZE 11
	//рандом
	int throws[SIZE_COUNT] = { 0 };
	int statistics[STAT_SIZE] = { 0 };
	srand(time(0));
	rand();
	for (int i = 0; i < SIZE_COUNT; ++i) {

		throws[i] = (rand() % 6 + 1) + (rand() % 6 + 1);
		statistics[throws[i] - 2]++;
	}
	for (int i = 0; i < STAT_SIZE; ++i) {
		printf("%2d %7d\n", i + 2, statistics[i]);
	}
	return 0;
}
#endif TASK_7
```

```
#ifdef TASK_9

int main() {
	srand(time(0));// код сдвига должен выполняться 1 раз
	rand();
	for (int i = 0; i < 10; ++i) {
		printf("%d\n", rand() % 21 - 10);

	}
	return 0;
}
#endif TASK_9
```

## МНОГОМЕРНЫЕ МАССИВЫ

Массивы в Си могут иметь много индексов
Обычным представление многомерных массивов являются таблицы значений, содержащие информацию в строках и столбцах
чтобы определить отдельный табличный элемент, нужно указать два индекса
* первый(по соглашению) показывает номер строки
* второй (по соглашению) - номер столбца

Таблицы или массивы, которые требуют двух индексов для указания отдельного элемента называются двумерными

Фактически двумерный массив - это массив , элементами которого являются одномерные массивы.

```
#ifdef TASK_10

int main() {
	
#define ROW 4
#define COL 5
	srand(time(0));
	int arr[COL][ROW] = { 0 };
	for (int i = 0; i < ROW; ++i) {
		for (int j = 0; j < COL; ++j) {
			arr[i][j] = rand() % 201 - 100;
			printf("%5d\t", arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}
#endif TASK_10
```

## УКАЗАТЕЛИ
 ЭТО ПЕРЕМЕННАЯ, КОТОРАЯ ХРАНИТ АДРЕС
 указатель может хранить адрес:
 - переменной
 * функции
 * массива
 * объекта
 * другого указателя

***для объявления указателя нам нужна звёздочка***

int *count = NULL, count = 0; - указатель // NULL - специальный макрос для обнуления указателей (можно писать 0, более с++ стиль)

## Операции над указателями
с указателями возможно выполнение 2-х операций
1. Операция взятия адреса - амперсант (возвращает адрес) -- можно применять только к переменным, константам (всем тем у кого есть адрес)
2. операция разыменования (косвенной адресации) - звёздочка -- можно применять только к тому, что хранит адрес (указатель) -- результат - значение хранящиеся по адресу.

**след опрос будет в виде код-ревью либо напишите код**

```
#ifdef TASK_11

int main() {

	int a = 10;
	int* pa = &a;
	printf("%x\n", a);
	printf("%x\n", pa);
	printf("%x\n", &a);
	printf("%x\n", *pa); // унарная операция разименования
	*pa = 7; // с помощью звездочки мы получили доступ к значению переменной а
	printf("%x\n", a);

	++*pa;

	printf("%x\n", a);

	*pa++; // смещение указателя.
	
	printf("%x\n", a);




	return 0;
}
#endif TASK_11
```

## АРИФМИТИЧЕСКИЕ ОПЕРАЦИИ С УКАЗАТЕЛЯМИ

1. к указателю можно прибавить целое число -- результат - указатель
2. из указателя можно вычесть целое число -- результат - указатель
3. к обычному указателю можно применить операции инкремента и декремента -- результат - указатель
4. из указателя можно вычесть указатель. -- результат - целое число
ВСЁ!

Арифмитические действия с указателями имеют смысл только если указатель ССЫЛАТСЯ НА МАССИВ ( или эл-т массива)

```
#ifdef TASK_12

int main() {
#define SIZE 10
	int arr[SIZE] = { 0 };
	for (int i = 0; i < SIZE; ++i) {
		arr[i] = i * 10;
		printf("%5d", arr[i]);

	}
	printf("\n");
	int* p = arr; //имя массива хранит адресс 1-го эл-а (имя массива - это указатель!!!)
	printf("%d\n", arr[4]); // значение 5-го эл-а
	printf("%d\n", p[4]); // значение 5-го эл-а 
	printf("%d\n", p + 4);
	printf("%d\n", arr + 4);
	printf("%d\n", *(p + 4));
	printf("%d\n", *(arr + 4));
	printf("%d\n", ++ * p);
	printf("%d\n", ++ * arr);
	printf("%d\n", *++ p);
	//printf("%d\n", *++arr); ytj,sxysq erfpfntkm
	return 0;
}
#endif TASK_12
```

----------------------------------
