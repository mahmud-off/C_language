# [КОД В ЭТОЙ ЛЕКЦИИ НЕ РАБОТАЕТ (НУ ИЛИ РАБОТАЕТ, Я ХЗ]()
--------------------------------------------------------------------------
# **Побитовые операции**

- могут выполняться только над целыми числами
- не изменяют своих операндов
- Результат - число
	выполняются над каждым битом числа по отдельности
	для того чтобы узнать результат операции число нужно перевести в 2-ю систему.


- & - И
- | - или
- ^ - XOR исключающее или (одинакокое чило --> 0, а елси разное , то 1)
- ~ - побитовое отрицание (0-->1 and 1-->0)
	когда отрицаем положительное число, то получаем отрицательное по модулю на 1 больше
	когда отрицаем отрицательное число, то получаем положительное число по модулю на 1 меньше.
	***!отрицаем 0, получаем -1!***


## СДВИГИ

операции зашиты в процессор

`<<` - сдвиг влево на 2 разряда (всегда добавляются нули) ==  умножение на 2 в степени
`>>` - сдвиг вправо на 2 разряда (если число положительное - то заполняем нулями, если отрицательное, то единицами) == деление на 2 в степени

--------------------------------------------------------------------------
## example_1: какой-то код
```
void read_file_by_word(FILE* in, FILE* out)
{
	while (!feof(in))
	{
		char temp[SIZE] = { 0 };
		fscanf(in, "%s", temp);
		fprintf(out, "%s", temp);
	}

}
//сумма чисел строки

int atoi(const char* s)
{
	int temp = 0;
	while (*s)
	{
		if (*s >= '0' && *s <= '9')
		{
			temp = temp * 10 + (*s - '0');
		}
		else {
			return 0;
		}
	}
		return temp;
}


void calculate_sum_of_numbers(FILE* in, FILE* out)
{
	int sum = 0;
	while (!feof(in))
	{
		char temp[SIZE] = { 0 };
		fscanf(in, "%s", temp);
		sum += atoi(temp);
		//fprintf(out, "%s", temp);
	}
	fprintf(out, "%d\n", sum);
}

int main(int argc, char *argv[])
{
	if (argc < 3)
	{
		fprintf(stderr, "Wrong format\n");
		return -1;
	}

	FILE* fin = fopen(argv[1], "r");

	if (!fin)
	{
		fprintf(stderr, "Can't open file for reading\n");
		return -2;
	}

	FILE* fout = fopen(argv[2], "w");


	if (!fout)
	{
		fprintf(stderr, "Can't open file for writing\n");
		return -3;
	}


	fclose(fout);
	fclose(fin);
	return 0;
}
```
--------------------------------------------------------------------------
# **Пользовательские типы данных**

***ПЕРЕЧИСЛЕНИЯ***  - набор именованных констант.
	именованные константы списка имеют тип int
	количество памяти выделяемой под переменную перечисления - это количество памяти необходимо для размещения значения типа int

Константы в перечислении мгут иметь префикс - общее имя типа. Это даёт дополнительную информацию о том, где находится объявление какие константы описаны в одном перечислениии а также какую концепцию являют собой константы

```
enum Color {
	COLOR_RED,
	COLOR_GREEN
	COLOR_BLUE
}
```
--------------------------------------------------------------------------
## example_2: именованные данные
```

enum LEVELS {LOW = 100, MEDIUM = 500, HIGH = 1000};
const char* levels[] = { "LOW", "MEDIUM", "HIGH" };

int main()
{

	int cur_level = 0;
	scanf("%d", &cur_level);
	if (cur_level < LOW)
		printf("Too low!!!\n\a");

	else if (cur_level > HIGH)
		printf("Too higher!!!\n\a");
	else
		printf("OK\n");
	printf("%s\n", levels[cur_level/MEDIUM]);
	return 0;

}
```
--------------------------------------------------------------------------
## example_3: то же самое
```
enum times {morningm = 1, day, evening = 10, night };// повторы могут быть и последовательно + 1 базово

int main()
{

	int n = 0;
	scanf("%d", &n);
	if (n == day)
		printf("You should work!\n");

	return 0;

}

```
--------------------------------------------------------------------------
# СТРУКТУРЫ

***Структуры*** - абстрактные пользовательские типы данных 

составленные типы данных, построенные с использованием других типов встроенных или пользовательских

1 - ***надо знать для чего мы это делаем***

--------------------------------------------------------------------------
