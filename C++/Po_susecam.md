## Перегрузка
- оператор присваивания можно использовать без предварительной перегрузки
```
	Rational operator+ (const Rational& right) const;

	Rational operator+ (int right) const;

	operator double()const { return (double)num / den; }

	bool operator==(const Rational& right)const;

	Rational& operator++();
	Rational& operator++(int);


	void printRtational()const;
private:
	int num, den;


};

//ПЕРЕГРУЗКА

//перегрузка оператора вывода в поток
std::ostream& operator<<(std::ostream& out,
	const Rational& right);


// ЕСЛИ ЛЕВЫЙ ОПЕРАНД ОПЕРАЦИИ НЕ ЯВЛЯЕТСЯ ЧЛЕНОМ НАШЕГО КЛАССА, ТО ЭТОТ ОПЕРАНД НЕ МОЕТ БЫТЬ ПЕРЕГРУЖЕН КАК ФУНКЦИЯ ЧЛЕНА КЛАССА

// перегрузка оператора взятия с потока

std::istream& operator>>(std::istream& in , Rational & right);

bool operator!=(const Rational& left, const Rational& right);

Rational& operator+=(Rational& left, const Rational& right);

Rational operator+(int left, const Rational& right);
```
в cpp:
```
// перегрузка оператора <<
std::ostream& operator<<(std::ostream& out, const Rational& right)
{
	right.printRtational();
	return out;
}

```

## Наследование
```
//наследование
// Класс круг будет наследоватья от точки
// делаем открытое наследование
class Circle : public Point
{
public:
	Circle(double x = 1, double y = 1, double r = 1) :Point(x, y), radius(r) {}
	void print()const;
	double get_radius()const { return radius; };
	void set_radius(double r) { radius = r; }
	
private:
	double radius;

};

class Cylinder : public Circle {

public:
	//в списке инициализации только конструкторы классов, которые указаны в заголовке классов.
	// Circle - прямой базовый класс, Point - косвенный базовый класс (потому что его нет в заголовке)
	Cylinder(double x = 2, double y = 2, double r = 2, double h = 2 ) :
		Circle(x, y, r), height(h) {}
	void print()const;
...
```

преобразования:
```
pc->print();
pp = pc; // из круга делается точка (операция называется срезка)ВОСХОДЯЩЕЕ ПРЕОБРАЗОВАНИЕ (доступно всегда и поддерживается средствами языка)
//pc = pp не хватает параметров --> ошибка НИСХОДЯЩЕЕ ПРЕОБРАЗОВАНИЯ (доступно не всегда)
//pc = (Circle*)pp; // настаиваем на нисходящем преобразовании ПОД ЗАПРЕТОМ!!!
pc->print();
pp->print();
```

### ПОЛИМОРФИЗМ - это один интерфейс, много методов (или различное поведение программы при вызове одной и той же функции
Существует дин и стат полиморф для того, чтобы реализовать дин полиморф нам надо наследование + виртуальные функции
- наследование - способ повторного использования кода
- Виртуальные функции - это функция с особенностью, которая связана с понятием связывание - это процесс подстановки адреса функции в точку вызова функции (бывает двух видов : 
	1. раннее (в момент компиляции) 
	2. позднее (во время работы программы))

### Механизм позднего связывания
- самое первое поле в объекте содержит указатель на таблицу виртуальных функций класса
- таблица одна, созаётся в момент компиляции
- таблица - это массив указателей на функции (любое имя функции - указатель на функции)
- для связки сигнатуры должны совпадать
- каждый из этих указателей ссылается на ту функцию, которую нужно вызывать для того или иного класса
- конструктор в той части, которая скрыта от нас, заполняет указатель на таблицу
- каждый объект настедуемого класса переписывает таблицу под себя

НАША СХЕМА:

Point <- Circle <- Cylinder

к базовому - это Восходящее преобразование, допустимо, реализует is-a

```
Cylinder cyl1;
//cyl1.print();
std::cout << cyl1;
cyl1.test();
pc = &cyl1;
//pc->print();
std::cout << *pc;
pc->test();
pp = &cyl1;
//pp->print();
std::cout << *pp;
pp->test();
pp = &c2;
pp->test();

//!!!!!!!!! механизм позднего связывания работает только при вызове функции через указатель либо ссылку
```

Абстрактный класс - класс, у которого не может существовать экземпляров
```
class Animal {
public:
	virtual void print()const = 0; // занулили адрес функции (это чистая виртуальная функци (её нельзя вызвать тк нет адреса))
	//как только в классе появляется чистая виртуальная функция, то объект этого класса нельзя создать, он становится абстрактным
	// абстрактный клас - объект нельзя создать, (класс есть, тип есть, объекта нет НУЖЕН ТОЛЬКО ДЛЯ СОЗДАНИЯ НАСЛЕДНИКОВ)
	// если только абстрактные функции - это чистый абстрактный класс (= интерфейс в других языках)
	/*

	*/
	
	Animal();
	virtual ~Animal(); // если в классе есть хотя бы 1 виртуальная функция, то диструктор должен быть виртуальным	Мы ОБЯЗАНЫ НАПИСАТЬ В БАЗОВОМ КЛАССЕ


};
```
При этом класс наследник : 
```

//надо переопределить витруальную функцию, чтобы изменить табл функций
class Dog :public Animal
{
public:
	Dog();
	virtual ~Dog(); // этот диструктор уже автоматом виртуальный, но можно написать virtual
	virtual void print()const override; // override в  — это ключевое слово, которое указывает, что виртуальная функция переопределяет поведение другой виртуальной функции.
};

```
--------------------------------------------------------------------------
# [ПО ПРЕЗАМ]()
--------------------------------------------------------------------------
## Определение классов, конструкторы, деструкторы, указатель `this`

- Класс – это абстрактный тип данных, содержащий данные (поля класса) и функции (методы), манипулирующие этими данными
- Конструктор - это специальный член класса, призванный инициализировать объект класса в момент создания. Синтаксически конструктор подобен функции, поэтому дальше будем называть его функцией. Имя конструктора совпадает с именем класса.
- Виды конструкторов: 
	1. Конструктор по умолчанию (default constructor)
	2. Конструктор копирования (copy constructor)
	3. Конструктор перемещения (move constructor)
	4. Конструктор инициализации (initial constructor)
- Необходимо иметь собственный конструктор по умолчанию, если в классе есть: 
	1. Ссылки 
	2. Константы
	3. Объекты других классов, не имеющих конструктора по умолчанию
- Необходим для инициализации: 
	1. Ссылок 
	2. Констант
	3. Объектов других классов, не имеющих конструктора по умолчанию
- Каждый класс имеет предопределенный конструктор копирования (пока программист не определит свой собственный) Работает в следующих случаях: 
	1. один объект явно инициализирует другой объект (например, в объявлении); 
	2. копия объекта передается параметру функции;
	3. генерируется временный объект (например, в качестве значения, возвращаемого функцией)
- Деструктор выполняет необходимые действия при разрушении объекта. Программист должен определять деструктор тогда, когда необходимо освободить ресурсы (системные объекты, память, файловые дескрипторы) при уничтожении объекта
- Ключевое слово `explicit`
	1. Запрет неявного вызова конструктора Если так определен конструктор копии и в классе нет конструктора перемещения, то: 
		1. нельзя передавать объект в функцию; 
		2. нельзя возвращать объект из функции.
- Каждый объект содержит указатель на самого себя – называемый указателем `this`. Этот указатель неявно присутствует как аргумент во всех ссылках на элементы внутри объекта. Чтобы функции класса знали, для какого объекта они вызываются, первый неявный параметр каждой функции – указатель `this`
--------------------------------------------------------------------------
## Константные объекты и константные функции. Статические члены класса
- Константные объекты Объект класса может быть создан в программе с использованием спецификатора const. Такой объект будет константным, то есть во время выполнения программы объект изменять нельзя. Для доступа к полям такого объекту можно использовать только функции, объявленные с суффиксом const – константные функции
- Ограничения, накладываемые на константные функции: 
	1. не может быть статической; 
	2. не может менять значения полей того объекта, для которого вызвана; 
	3. может вызывать только другие константные функции класса.
- Статические поля класса:
	1. Создаются в одном экземпляре
	2. Доступны всем объектам класса 
	3. Используются для обмена данными между объектами одного класса, для счетчика созданных экземпляров класса и т.д.
	4. Существуют, даже если не создано ни одного объекта класса
	5. Для работы с ними нужны статические функции
- Ограничения, накладываемые на статические функции:
	1. не может быть константной 
	2. не может быть виртуальной 
	3. нет указателя this
	4. нельзя обратится к нестатическим полям
--------------------------------------------------------------------------
## Перегрузка операторов
- Дружественность (friend)
	1. Классы могут дружить с другими классами, отдельными функциями других классов, с обычными функциями 
	2. Друзья класса получают доступ к private части класса
	3. Отношения дружественности требуют явного объявления 
	4. Отношения дружественности несимметричны 
	5. Отношения дружественности не транзитивны 
	6. Друзья не наследуются 
	7. Отношения дружественности нарушают инкапсуляцию
- Перегрузка операторов позволяет использовать встроенные операторы для пользовательских типов
- Правила перегрузки 
	1. Оператор реализуется как функция, в имени которой есть слово `operator` и знак операции
	2. Оператор может быть перегружен как член класса, либо как внешняя функция
	3. Операторы `-> [] () =` должны быть перегружены как члены класса
- Правила перегрузки. ***Нельзя:*** 
	1. создавать новые лексемы операторов;
	2. изменять арность операции; 
	3. изменять приоритет операции; 
	4. изменять ассоциативность операции; 
	5. перегружать следующие операторы: `:: . .* ?: sizeof typedef` 
	6. изменить смысл операции для встроенных типов.
- Особенности перегрузки инкремента/декремента 
	1. Операции существуют в двух формах:  префиксная; постфиксная. 
	2. У постфиксной формы появляется фиктивный параметр `int`
- Перегрузка копирующего оператора `=` Можно использовать без предварительной перегрузки 
- Алгоритм 
	1. Защита от самоприсваивания 
	2. Очистка ранее выделенной памяти 
	3. Выделение нового блока памяти и работа с ним 
	4. Возврат измененного объекта
--------------------------------------------------------------------------
## Наследование
- Наследование - это способ повторного использования кода, при котором новые классы создаются из уже существующих классов путем заимствования их атрибутов и функций и обогащения этими возможностями новых классов
- Не наследуются: **конструкторы; деструктор; оператор присваивания; друзья класса.**
--------------------------------------------------------------------------
## Виртуальные функции и полиморфизм
- Полиморфизм - это возможность для объектов разных классов, связанных с помощью наследования, реагировать различным образом при обращении к одной и той же функции-элементу.
- Говорят, что полиморфизм – это один интерфейс и множество методов
- Полиморфизм в С++ - это **Наследование (public) + Виртуальные функции**
- Виртуальные функции - Интерфейсные функции. Их можно переопределить в каждом производном классе `virtual void draw() const;` Реализуют позднее связывание 
- Функция, объявленная виртуальной в базовом классе, остается виртуальной до конца иерархии 
- Полиморфный класс – класс, в котором есть хотя бы одна виртуальная функция
- Абстрактный класс - класс, объекты которого не могут быть созданы 
- Чтобы класс стал абстрактным, в нем должна быть хотя бы одна чистая виртуальная функция `virtual void draw() const = 0;` 
- Чистая виртуальная функция – это функция, тело которой равно 0. Если в производном классе не переопределена хотя бы одна чистая виртуальная функция, класс останется абстрактным
- Виртуальный деструктор Если у класса имеются виртуальные функции, то классу необходимо создать виртуальный деструктор. В этом случае, если объект в иерархии уничтожен явным использованием операции `delete`, примененной к указателю базового класса на объект производного класса, то будет вызван деструктор соответствующего класса
- Устранение ошибок при работе с виртуальными функциями Виртуальные функции рекомендуется переопределять со словом `override` Для запрета дальнейшего переопределения используют слово `final`
--------------------------------------------------------------------------
