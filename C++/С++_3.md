# [Классы. Продолжение]()
--------------------------------------------------------------------------
## nullprt
 `nullptr` - служебное слово применяется только к указателям показывает, что указатель ни на что не ссылается. *(C++ style)*
## new/delete
***Если у `new` стоят квадратные скобки, то после `delete` тоже надо ставить ПУСТЫЕ квадратные скобки***

Example_1: Выделение памяти.
`arr = new int[capacity];`
-------------------------------------------------------------------------------------------------------------
**Синтаксис: ** 
	`new тип данных []- массив, внутри - сколько надо`
-  В С++ появились операторы встроенные в язык по работе с дин-ой памятью `new` - выделение `delete` - освобождение
	- `new` может выделить память под 1 объект и под массив
	- `delete` может освободить из под 1-го объекта и может освободить память из под массива объектов
	- может быть ошибка при выделении под 1 объект и удалили из под массива
	-  если выделить под массив и удалить из под объекта либо ошибка либо утечка --> (зависит от диспетчера памяти виртуальной системы, если не сможет отловить, то будет синий экран смерти)
--------------------------------------------------------------------------
## this

Example_2: this_1
```
Vector::Vector(int size, int val):Vector(size)
{
	for (; this->size < capacity; ++this->size) { 
		arr[this->size] = val;
	}
}
```
--------------------------------------------------------------------------
- первый неявный параметр каждой не статической функции класса - это адрес объекта (указатель на объект) на который функция ссылается  - this --> это указатель
- тут `size` **параметр** экранирует `size` **поле** можно получить двумя способами: переименовать параметр или использовать `this`.
Example_3: this_2
```
Vector::Vector(int size):capacity(size), size(0)
{
	arr = new int[capacity]; // this->arr = new int[this->capacity];
}
```
--------------------------------------------------------------------------
- Тут `arr = new int[capacity];` = `this->arr = new int[this->capacity];`
## Конструктор и Деструктор

### Конструкторы

Example_4: Cpp файл класса Vector
```
Vector::Vector():arr(nullptr), size(0), capacity(0)
{
}

Vector::Vector(int size):capacity(size), size(0)
{
	arr = new int[capacity];
}

Vector::Vector(int size, int val):Vector(size)
{
	for (; this->size < capacity; ++this->size) { 
		arr[this->size] = val;
	}
}

Vector::Vector(const Vector& ref):Vector(ref.capacity)
{
	for (; this->size < capacity; ++this->size) { 
		arr[this->size] = ref.arr[this->size];
	}
}

Vector::~Vector()
{
	delete[]arr;
}

void Vector::print() const
{
	if (size) {
		for (int i = 0; i < size - 1; i++) {
			std::cout << arr[i] << " ";
		}
		std::cout << std::endl;
	}
	else {
		std::cout << "Vector is empty" << std::endl;
	}
}

int& Vector::getElem(int index)
{
	if (index >= 0 && index < size) 
	{
		return arr[index];
	}
}
```
--------------------------------------------------------------------------
- `Vector::Vector(int size):capacity(size), size(0)` - `capacity(size)` - это параметр. **НЕ ПОЛЕ** а `size(0)` - поле ***(перед круглыми скобками - поле, внутри - параметр)***
- `Vector::Vector(int size, int val):Vector(size)` - такой конструктор называется ***делегируемым***, *(конструктор, который вызывает другой конструктор)*
- иногда бывает что вы вызываете другие конструкторы и тело вашего конструктора пусто
- в списке инициализации вызывается конструктор того же самого класса, то есть мы имеем возможность при создании объекта вызывать несколько конструкторов *(есть момент что в проектах 2000-2010 стандарт до 11 года, то этот код незаконен, это приведёт к тому что будет создан новый временный объект будет инициализирован, затем умрёт, потому что не сохраняется никуда.)*

```
Vector::Vector(const Vector& ref):Vector(ref.capacity)
{
	for (; this->size < capacity; ++this->size) {
		arr[this->size] = ref.arr[this->size];
	}
}
```
- из одного объекта получаем доступ к `private` части другого объекта по ссылке
- `void Vector::print() const ` - `const` всегда пишем когда функция не меняет полей класса
```
int& Vector::getElem(int index)
{
	if (index >= 0 && index < size) 
	{
		return arr[index];
	}
}
```
- `int& Vector::getElem(int index)` - `getElem` открывает доступ к `private` части класса - это уязвимость это ДЫРА в защите класса. (ЕСЛИ ВЫ ДЕЛАЕТЕ ЭТО В СВОИХ КЛАССАХ, ВЫ ДОЛЖНЫ ПОНИМАТЬ ЧТО ВЫ ДЕЛАЕТЕ)
--------------------------------------------------------------------------
### Деструктор
Example_?: Деструктор и его тело.
```
class Vector {
public:
	Vector();
		
	~Vector();
	
	void print() const;

	int &getElem(int index);
private:
	int* arr;
	int size;
	int capacity;
};
-----------------------------------------------------------------------------------
Vector::~Vector()
{
	delete[]arr;
}
```
--------------------------------------------------------------------------
- `~Vector();` - деструктор
- Имя деструктора совпадает с именем класса
- деструктор отрицает конструктор `(~)`
- деструктор заработает когда закончится время жизни
- деструктор вызывается очень редко, поэтому явным образом МЫ В СВОИХ ПРОГРАММАХ не вызываем деструктор
- Кол-во параметров у деструктора всегда пустой
- ***если программа перестает падать, как только вы стираете деструктор, то проблема в другом место (либо в конструкторах либо в операторе присваивания)***
--------------------------------------------------------------------------
## Конструктор копирования (явный/неявный)

Example_4: Класс Vector
```
class Vector {
public:
	Vector();
	Vector(int size);
	Vector(int size, int val);
	
	//Vector(const Vector& ref);
	explicit Vector(const Vector& ref);
	
	~Vector();
	void print() const;

	int &getElem(int index);
private:
	int* arr;
	int size;
	int capacity;
};
```
--------------------------------------------------------------------------
- `Vector(const Vector& ref);` - конструктор копирования
- ссылка константная, потому что конструктор копирования не изменяет то что он копирует
- `explicit Vector(const Vector& ref);` - `explicit` запрещает неявный вызов конструктора копирования
--------------------------------------------------------------------------
Example_?: Main
```
int main()
{
    int a = 5;
    int b = a;
    Vector v1(5);
    
    v1.print();

    Vector v2(5, 4);
    
    v2.print();

    //Vector v3(); 
    
    //Vector v3;

    //Vector v3 = v2;
    
    Vector v3(v2);
    
    
    v3.print(); 
    
    v2.getElem(2) = 10;
    
    v2.print();
    v3.print();
    
    return 0;
}
```
--------------------------------------------------------------------------
- `Vector v3();` - это объявление функции (принимает ничего и возвращает вектор) по правилу право-лево *(чтобы пофиксить надо убрать скобки)*
- `Vector v3;` - теперь объект
- `Vector v3 = v2;` - неявный вызов конструктора копирования (можно создать объект как копию другого объекта)
- `Vector v3(v2);` - явный вызов конструктора копирования он предоставляется до тех пор пока мы не напишем свой собственный конструктор копирования (когда класс становится не тривиальным) 
- ***если в классе есть УКАЗАТЕЛЬ, то значит надо делать свой собственный конструктор копирования, деструктор, оператор присваивания***
--------------------------------------------------------------------------
